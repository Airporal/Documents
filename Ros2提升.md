# ROS2提升

> 介绍机器人学和ROS2特殊功能包用法





## 一：机器人学:robot:

### 1. 运动学

机器人学首先研究运动学。可以分为正运动学和逆运动学，正运动学指由控制施加力到运动状态变化的整个过程，逆运动学与之相反

在机器人控制中，机械臂的控制是最具有普适性的。一般常需要进行由状态量推算施加控制力的逆运动学分析。

机械臂的运动由**旋转矩阵**来表述。

#### 1.1 旋转矩阵

旋转矩阵首先是描述两组标准正交基的坐标系之间的旋转变换关系，可以概括为：
$$
[\eta_1,\eta_2,\eta_3]=[\xi_1,\xi_2,\xi_3]{}_B^A\!R
$$
其中：A系下的正交坐标基为：
$$
\xi_1、\xi_2、\xi_3
$$
B系下的正交坐标基为：
$$
\eta_1、\eta_2、\eta_3
$$
R为B系相对于A系的旋转矩阵。即正交坐标基在A系下的表示。

+ 坐标系的旋转矩阵是正交阵，自由度为3

+ 使用旋转矩阵表示将一个坐标系旋转变换：

将A系绕X轴旋转：
$$
A' =[\xi_1、\xi_2、\xi_3]\begin{bmatrix}
1 & 0 & 0 \\
0 & cos\alpha & -sin\alpha  \\ 0 & sin\alpha & cos\alpha 
\end{bmatrix}
$$
将A系绕Y轴旋转：
$$
A' =[\xi_1、\xi_2、\xi_3]\begin{bmatrix}
cos\beta & 0 & sin\alpha \\
0 & 1 & 0  \\ -sin\alpha & 0 & cos\beta 
\end{bmatrix}
$$
将A系绕Z轴旋转：
$$
A' =[\xi_1、\xi_2、\xi_3]\begin{bmatrix}
cos\gamma & -sin\gamma & 0 \\
sin\gamma & cos\gamma & 0  \\ 0 & 0 & 1 
\end{bmatrix}
$$
复杂的旋转可以由以上三种基本旋转组合。

+ fixed Angle的组合旋转

将一个坐标系绕着固定的坐标轴进行旋转。

**由于矩阵的乘法不满足交换率，因此，先绕x轴转20度再绕y轴转10度与先绕y轴转10度再绕x轴转20度得到的结果不一样。**

规定：fixed-Angle的旋转以X-Y-Z的顺序进行。由于旋转轴的固定，可以将整个旋转依次进行即可得到旋转矩阵。

旋转矩阵为：
$$
{}_B^AR_{XYZ}(\gamma,\beta,\alpha)
=\begin{bmatrix}c\alpha c\beta&c\alpha s\beta s\gamma-s\alpha c\gamma&c\alpha s\beta c\gamma+s\alpha s\gamma\\s\alpha c\beta&s\alpha s\beta s\gamma+c\alpha c\gamma&s\alpha s\beta c\gamma-c\alpha s\gamma\\-s\beta&c\beta s\gamma&c\beta c\gamma\end{bmatrix}=\begin{bmatrix}r_{11}&r_{12}&r_{13}\\r_{21}&r_{22}&r_{23}\\r_{31}&r_{32}&r_{33}\end{bmatrix}
$$
即：公式（4,5,6）依存左乘。

根据正交阵，可以由旋转矩阵的值解出以x、y、z为旋转方向的固定轴旋转的角度：


$$
if :\beta \neq 90^\circ:\\
\begin{aligned}
&\beta=Atan2(-r_{31},\sqrt{r_{11}{}^{2}+r_{21}{}^{2}}) \\
&\alpha=Atan2(r_{21}/c\beta,r_{11}/c\beta) \\
&\gamma=Atan2(r_3/c\beta,r_{33}/c\beta)
\end{aligned}
$$

$$
if :\beta = 90^\circ则\alpha=0^\circ,\gamma=
Atan2(r_{12},r_{22})
$$

$$
if :\beta = -90^\circ则\alpha=0^\circ,\gamma=
-Atan2(r_{12},r_{22})
$$

+ Euler Angle的组合旋转

当以动系的自身坐标轴为旋转轴时，成为Euler Angle旋转，一般知道旋转后的位置。

规定按照Z、Y、X的顺序旋转。Euler Angle角度解算时，如果正向思考旋转过程，由于角度不是相对于固定轴，因而难以计算在A系下的旋转矩阵，此时需要逆向思考整个过程，即先将B系绕X逆向旋转，再绕Y逆向旋转，最后绕Z逆向旋转，从而回到原位置，每次旋转相对于B系当前轴。
$$
{}_B^AR_{ZYX}(\alpha,\beta,\gamma)={}_{B_y}^AR_{Z}(\alpha,0,0){}_{B_x}^{B_y}R_{Y}(0,\beta,0){}_B^{B_x}R_{X}(0,0,\gamma)
$$
得到和fixed Angle一样的旋转矩阵表达，因此解算角度方法也一样。

==**若按照指定的顺序旋转，则fixed Angle下绕固定的轴旋转一定角度得到的结果和Euler Angle下绕变化的轴旋转相同的角度得到的结果一样**==



按照以上思想，在Euler Angle下，当其它旋转组合时，如绕z-绕y-绕z旋转，得到的旋转矩阵、旋转矩阵元素与角度对应关系都可以推出来。总共有12种旋转组合。

+ 使用旋转矩阵表示A系中点的旋转：

假设P点在A系中的坐标为(x,y,z)，求将它旋转后在A系中的坐标。此时虽然只研究一个坐标系，但是可以假设一个中间坐标系，中间坐标系施加指定的旋转后得到B系，而P随着一起旋转，固P在B系中的坐标为（x,y,z）则求其在A系中的坐标P’：
$$
[x',y',z'] = {}_B^A\!R[x,y,z]
$$

#### 1.2 运动表达

空间中的运动可以分解为旋转和平移两部分，分别使用运动坐标系相对于空间惯性系的旋转矩阵与运动坐标系原点位置表示。

![image-20240915104712115](https://cdn.jsdelivr.net/gh/Airporal/Pictures/img/202409151047178.png)

空间中点的运动为：
$$
{}^AP_{3\times1}={}^A_BR_{3\times3}*{}^BP_{3\times1}+{}^AP_{B_{org}3\times1}
$$
矩阵形式为：
$$
\begin{bmatrix}{}^AP\\1\end{bmatrix}=
\begin{bmatrix}{}^A_BR&&&{}^AP_{B org}\\0&0&0&1\end{bmatrix}\begin{bmatrix}{}^BP\\1\end{bmatrix}
$$
连续性的运动可拆解为连续性的运动矩阵相乘：
$$
{}^A_BT={}^A_CT{}^C_DT{}^D_BT
$$
与Euler Angle类似，连续的运动变化分析时，需要逆向分析整个过程。
$$
\begin{aligned}{{}^{A}P}&=
{}_{B}^{A}T_{C}^{B}T_{D}^{C}T^{D}P\\&
=\begin{bmatrix}{}_{B}^{A}R_{C}^{B}R_{D}^{C}R&&&{}^{A}P_{B org}+{}_{B}^{A}R^{B}P_{C org}+{}_{B}^{A}R_{C}^{B}R^{C}P_{D org}\\0&0&0&1\end{bmatrix}
={}_{D}^{A}T^{D}P\end{aligned}
$$
对于点自身的运动描述，先旋转然后位移，也可用以上方程描述。

运动的逆变化：旋转部分仍然为正交阵，逆就是转置；位移部分需要取相反的坐标原点关系：
$$
_A^BT^{}=_B^AT^{-1}=\begin{bmatrix}{}_B^AR^T&&&-{}_B^AR^T{}^AP_{B org}\\0&0&0&1\end{bmatrix}
$$

+ 结构的表达：

![image-20240915104721472](https://cdn.jsdelivr.net/gh/Airporal/Pictures/img/202409151047548.png)

杆件可以抽象为joint和link组成，对于每个杆件而言，描述的参数为：
$$
(a_{i-1},\alpha _{i-1},d_i,\theta_i)
$$
分别表示：

​	joint所在的轴和下一个杆件的轴的距离

​	joint所在的轴和下一个杆件的轴的夹角

​	joint轴上前后两个垂线之间的位置

​	joint轴上前后两个垂线之间的夹角

+ 杆件的Frame建立规则：

​	以转轴的方向为z的方向（移动副以移动方向），以与下一个杆件轴垂线方向为x的方向，y由右手定则确定，原点在与下一轴垂线的交点。角度方向以右手定则判断。

#### 1.3 顺运动学

![image-20240915104730368](https://cdn.jsdelivr.net/gh/Airporal/Pictures/img/202409151047429.png)

使用旋转矩阵进行相邻杆件之间的点坐标转换方法：

p在i杆的Frame已知，则在i-1杆的Frame上的坐标为：
$$
{}^iP={}^i_{i-1}T*{}^{i-1}P
$$
而由i-1系到i系的坐标系变化过程可以理解为：
$$
由i-1系绕x轴旋转\alpha_{i-1}->沿垂线平移a-1->绕z轴旋转\theta->沿z轴平移d_i
$$
即：
$$
{}^i_{i-1}T = {}^{i-1}_{R}T{}^R_{Q}T{}^Q_{P}T{}^P_{i}T
$$
代入1.2中的表达，得到两杆件之间的旋转矩阵为：
$$
\begin{bmatrix}c\theta_i&-s\theta_i&0&a_{i-1}\\s\theta_ic\alpha_{i-1}&c\theta_ic\alpha_{i-1}&-s\alpha_{i-1}&-s\alpha_{i-1}d_i\\s\theta_is\alpha_{i-1}&c\theta_is\alpha_{i-1}&c\alpha_{i-1}&c\alpha_{i-1}d_i\\0&0&0&1\end{bmatrix}
$$
同理，多个相邻的杆件之间的坐标变换，可以用使用各个旋转矩阵得到。

分析方法：

1. 画出所有的活动机构的Frame，个数为自由度-1
2. 画出开始和结尾部分的Frame
3. 以DH表格的形式，写出所有的Frame的参数，写的时候可以对Frame进行上文指定的变换以方便找到。
4. 根据参数得到旋转矩阵
5. 每个运动需要建立在两个接触杆件上的两个坐标系描述，总坐标轴数等与自由度+1

**通过控制各个关节的参数【Actuator Space]，进而控制末端位置【joint Space】的方法为顺运动学。**

#### 1.4 逆运动学

根据指定需要到达的坐标点，反算需要实现的关节运动。逆运动学解算实际上运用的更加广泛，如目标跟踪任务等。

+ 逆运动学解算往往可以得到多个解，可添加约束条件以获得需要的解
+ 解算思路：
  + 确定需要到达的点在world Frame下的坐标
  + 在该点下建立和最后一个关节Frame相平行的Frame
  + 计算该点与World Frame的转换矩阵、结构自身各个关节的转换矩阵
  + 由已知转换矩阵求解需要的旋转矩阵，进而确定运动姿态

能解系求取的一般只有前面几个运动参数，此时如果将最后的3个旋转轴设置为重合，则每次都是绕旋转后的z轴旋转，符合Euler Angle，则其旋转矩阵可以由Euler Angle解算出对应的运动参数。

注意点：

+ 除了结构自身关节的Frame外，可根据需要建立合适的Frame以方便求解分析
+ 根据转换矩阵为正交阵来求逆，已得到未知的转换矩阵
+ 根据转换矩阵中坐标与旋转的关系求解运动参数时，可设置合适的中间变量以方便求解。

#### 1.5 轨迹规划

根据起点与终点，确定空间中经过的点以及对应的转换矩阵，需要确保轨迹和速度的连续性，称为轨迹规划。

Joint-space下的轨迹规划：在各个关节上做规划，对姿态进行规划。

1. 转换矩阵具有十六个参数，而空间运动为三个自由度移动和三个自由度转动，直接使用转换矩阵会导致得到的规划结果不满足转换矩阵要求，所以需要将转换矩阵使用六个参数来表示。
2. I.K：根据手臂的目标末端点状态，得到各个关节的末状态。
3. Trajectories plan将所有的关节初状态、末状态规划为smooth trajectories。
4. F.K 根据各个关节的smooth trajectories推算手臂末端点的运动轨迹，验证轨迹可行性。

Certesian-space下的轨迹规划：直接对手臂末端点位置进行规划。

1. 用六个参数表示转换矩阵。

2. 将所有末端点状态规划为smooth trajectories

3. I.K将规划好的所有手臂末端轨迹经过的点转化为各个Joint的状态

4. 验证各个Joint是否能达到指定状态。

   Certesian-space下需要进行I.K次数太多，带来极大计算压力，但是轨迹更加直观。

Smooth trajectories 原则：

1. 相邻时间段的规划需要用不同参数的同类型函数拟合
2. 定义各个函数的边界条件，包括起点、终点各自的位置和速度
3. 通常以多项式来规划轨迹

**单段多项式单独规划举例：**
$$
\theta(\delta t)=a_0+a_1\delta t+a_2\delta t^2+a_3\delta t^3
\\t\in(t_i,t_{i+1}),\delta t\in[0,t_{i+1}-t_i],\Delta t =t_{i+1}-t_i
$$
通过四个边界条件解出多项式中四个未知数。得到矩阵运算为：
$$
\begin{bmatrix}\theta_i\\\theta_{i+1}\\\dot{\theta}_i\\\dot{\theta}_{i+1}\end{bmatrix}=\begin{bmatrix}1&0&0&0\\1&\Delta t&\Delta t^2&\Delta t^3\\0&1&0&0\\0&1&2\Delta t&3\Delta t^2\end{bmatrix}\begin{bmatrix}a_0\\a_1\\a_2\\a_3\end{bmatrix}
$$
当系数阵满秩序时，根据四个边界条件及最大的时间间隔可解上述方程。即行列式不为0：
$$
det(\begin{bmatrix}1&0&0&0\\1&\Delta t&\Delta t^2&\Delta t^3\\0&1&0&0\\0&1&2\Delta t&3\Delta t^2\end{bmatrix})=-\Delta t^4\neq 0 
$$
得到：
$$
\begin{bmatrix}a_0\\a_1\\a_2\\a_3\end{bmatrix}=\begin{bmatrix}1&0&0&0\\0&0&1&0\\-\frac{3}{\Delta t^2}&\frac{3}{\Delta t^2}&-\frac{2}{\Delta t}&-\frac{1}{\Delta t}\\\frac{2}{\Delta t^3}&-\frac{2}{\Delta t^2}&\frac{1}{\Delta t^2}&\frac{1}{\Delta t^2}\end{bmatrix}\begin{bmatrix}\theta_i\\\theta_{i+1}\\\dot{\theta}_i\\\dot{\theta}_{i+1}\end{bmatrix}
$$
初始条件设置准则：

a. 不建议直接单独对速度边界条件进行设定，因为不仅难以实现而且过于复杂。

b. 自动生成速各个时间点的速度边界条件：

+ 如果该点附近，速度变号，则设该点速度边界条件为0
+ 如果该点附近速度不变换，则设该点速度为前一点速度和后一点速度的平均值。

**多段单项式一起规划举例：**

对两端连续的两个多项式进行联立求解，共八个未知数，除了三个点的位置、速度共六个条件外，还有第一段右边界速度、加速度和第二段左边界速度、加速度相等。

最终求解得到矩阵方程：
$$
\begin{bmatrix}\theta_0\\\theta_1\\\theta_1\\\theta_f\\\theta_0\\\theta_f\\0\\0\end{bmatrix}=\begin{bmatrix}1&0&0&0&0&0&0&0\\1&\Delta t_1&\Delta t_1^2&\Delta t_1^3&0&0&0&0\\0&0&0&0&1&0&0&0\\0&0&0&0&1&\Delta t_2&\Delta t_2^2&\Delta t_2^3\\0&1&0&0&0&0&0&0\\0&0&0&0&0&1&2\Delta t_2&3\Delta t_2^2\\0&1&2\Delta t_1&3\Delta t_1^2&0&-1&0&0\\0&0&2&6\Delta t_1&0&0&-2&0\end{bmatrix}\begin{bmatrix}a_{10}\\a_{11}\\a_{12}\\a_{13}\\a_{20}\\a_{21}\\a_{22}\\a_{23}\end{bmatrix}
$$
有解条件为时间间隔不为0。

c. General Cubic Polynomials方法

+ 设总共有N+1个点，N段轨迹，中间点N-1个（可以是末端点的位置，也可以是关节的位置）

+ N段轨迹共有N个多项式、4N个参数需要求解，因此需要4N个方程
+ 每个中间点在两个轨迹上，因此得到2（N-1）个位置的方程，加上初始点和末端点各一个方程，共2N个
+ 中间点的速度、加速度连续，左右相同得到2（N-1）个方程
+ 剩下的两个方程：
  + 可以定义初始加速度=0、末端加速度=0得到两个方程
  + 可以定义初始速度、末端速度得到两个方程
  + 如果初始点和末端点重合，则定义速度、加速度相同，得到两个方程。

在使用以上a、b、c的方法得到多项式拟合的各个自由度运动关于时间的函数后，即可组成连续的轨迹，形成控制指令。

#### 1.6 速度平滑规划

轨迹规划时，要避免速度的突变，否则会造成加速度难以实现。

如果需要各个段匀速直线运动，则只需要确定速度和变化速度即可完成轨迹的规划。

通常将位置变化曲线的速度突变段，添加线性的二次函数，使得存在一个短暂的加速（或减速）过程。

设置方法：

+ 在速度突变点的领域内进行二次多项式平滑处理，通过前后速度值，与所设置的领域大小或者所设置的加速度大小，求得平滑的二次函数表达。
+ 通过多段函数的方式形成控制指令。
+ 由于真实joint受力复杂，难以实现精确的加速度控制，因此常常设置变速时间而不是加速度。
+ 二次平滑后，轨迹不再通过原来的点，可以在需要通过的点附近取其它点，以该点为二次平滑中点，使得最后平滑后经过需要通过的点。

规划的轨迹可能对于joint来说难以实现，因此需要结合joint来进行规划调整。

通过设置变化时间的方式进行速度规划：

+ 在轨迹经过的点的基础上，设置每段轨迹需要达到的速度，一般为位移除时间，首尾两端需要进行时间的平移。
+ 在速度的基础上，结合设置的变化时间，设置变化的加速度
+ 列出各个时间段对应的加速轨迹、匀速轨迹表达式
+ I.K得到关节的运动值，最终得到轨迹

### 2.动力学



## 二： Motion Plan

> 移动机器人运动规划学习与实战

### 2.1 基于图搜索

#### 2.1.1 概念

+ Configuration Space

​	表示机器人所有可能运动姿态的空间，在Configuration Space中，机器人位置被表示为一个R3的点，姿态被表示为SO(3)的点。需要将环境障碍物转为C-Space下的C-obstacle以方便完成避障

+ Workspace

机器人所处的环境空间

+ 障碍物的C-Space空间转化

​	将障碍物转化为C-space空间下，从而方便机器人避障，转换方法是根据机器人的几何外形，抽象机器人为中心点和尺寸，将障碍物膨胀到该尺寸，将机器人变为一个点。这就将机器人运动规划转化为不考虑机器人尺寸的点的规划。

+ 图

用节点和边表示空间中的网格，节点和节点之间通过单向或双向的边来连接。

![image-20250328113445346](https://gitee.com/airporal/image_hub/raw/master/img/202503281134557.png)

#### 2.1.2 图搜索原理

图搜索将机器人与环境表示为C-space中的点，通过图来记录各个节点。主要过程如下：

:a:将起点放入OpenList中，OpenList存放所有将被访问的点。

:b:循环：从OpenList中pop​一个点，然后查找该点连接的其它节点，将这些节点放入OpenList中，放入的顺序由用户指定。将所有pop过的点放入CloseList中以防止重复访问。

🆎结束：遍历完所有的点后结束，选择到达目标点代价最小的路径执行。

##### 方法一：广度优先搜索BFS:+1:

广度优先搜索维护的List是一个队列，遵循先入先出的原则搜索节点。

![image-20250328115521349](https://gitee.com/airporal/image_hub/raw/master/img/202503281155525.png)

##### 方法二：深度优先搜索DFS:no_good:

深度优先搜索维护的List是一个堆栈，遵循先入后出的原则搜索节点。

![image-20250328115024166](https://gitee.com/airporal/image_hub/raw/master/img/202503281150320.png)

> [!IMPORTANT]
>
> **DFS不一定可以找到最近路径，而BFS一定可以找到最优路径**

---

##### 方法三：贪心算法

​	自定义一种选择节点的策略，而不是简单的遵循顺序来选择下一个pop的节点，这个策略就叫做一种启发。策略需要简单以减少计算负担，常用的策略包括欧拉距离最近或曼哈顿距离最近原则。

​	当存在障碍物的时候，策略如果无法考虑障碍物信息，会使得贪心算法会陷入局部最优。

![image-20250328120532352](https://gitee.com/airporal/image_hub/raw/master/img/202503281205524.png)

> [!NOTE]
>
> **<font color=red>以上算法将节点之间移动的消耗视为相同，然而移动到相邻节点的消耗很可能不同，此时考虑Dijkstra和A*算法</font>**

##### 方法四：Dijkstra算法

​	Dijkstra算法选择下一个pop的节点的方法是根据其对应的G值来选择，而某个节点的G值的计算方法是从起点沿着某条路径到达该点的所有消耗的和。

0️⃣维护的List是一个根据G值排列节点的数据结构，初始化起点的G值为0，所有其它节点的G值为无穷（表示未探索）,并根据实际约束来初始化不同节点之间移动的消耗C值。

:one:循环：pop一个最小G值的节点，探索该节点周围所有G值为无穷的未探索点，计算这些未探索点的G值：同时计算其它已有G值的点，如果大于当前的新的G值，则更新该点路径。
$$
G(m)=G(n)+C_{n->m}
$$
:two:当List为空时表示搜索完毕，且未找到目标点，返回搜索失败。当n是目标点时，表示搜索到最短路径，返回搜索成功，并根据CloseList来返回搜索的路径。

![image-20250328122559120](https://gitee.com/airporal/image_hub/raw/master/img/202503281225286.png)

Dijkstra算法没有考虑终点信息，不具有任何启发性，当运动代价相同时和BFS算法一样。

##### 方法五：A*算法

​	A*算法在Dijkstra算法的基础上考虑当前节点和目标节点的估计损失h(n)，最终通过g(n)和h(n)一起来评估List中pop的节点。

0️⃣维护的List是一个根据f值排列节点的数据结构，初始化起点的f值为0，所有其它节点的f值为无穷（表示未探索）,并根据实际约束来初始化不同节点之间移动的消耗C值。同时和Dijkstra一样维护一个G值表。
$$
F(n)=G(n)+h(n)
$$
:one:循环：pop一个最小F值的节点，探索该节点周围所有G值为无穷的未探索点，计算这些未探索点的G值：同时计算其它已有G值的点，如果大于当前的新的G值，则更新该点G值。根据自己定义的h值计算方法，计算出所有未探索的节点的h值，最后计算所有更新G值的节点的F值。
$$
G(m)=G(n)+C_{n->m}
$$
:two:当List为空时表示搜索完毕，且未找到目标点，返回搜索失败。当n是目标点时，表示搜索到最短路径，返回搜索成功，并根据CloseList来返回搜索的路径。

![image-20250330101418384](https://gitee.com/airporal/image_hub/raw/master/img/202503301014611.png)

> [!CAUTION]
>
> ​	A*算法的启发函数h设置不合理会使得无法找到最短路径，**启发函数估计的消耗值一定要小于真实值才能保证找到最短路径**。一般欧拉距离能保证而曼哈顿距离不一定能保证。无穷范数也能保障，当启发函数设置为恒为0的时候就是Dijkstra算法。

​	**某些时候最短路径不一定能保障速度最快，其原因是遭遇到一些障碍物使得机器人的运动变化大，无法保持高速运动，此时可以使用一种加权值的A*算法：**
$$
F(n)=G(n)+\varepsilon*h(n);\varepsilon>1
$$
理论上已经证明，带权重的A*所带来的损失不会小于普通A\*。

选择合适的启发函数可能会在相同损失的情况下，使用更短的时间、拓展更少的节点来找到最短的路径。

对角线的启发函数估计的消耗值与真实消耗值相同。

---

​	A*算法效率提升(Tip Breaker)：由于到达目标节点的最短路径不止一条，不同中间节点的f值也可能相同，会具有多条存在对称性的最短路径，使得搜索过多无用节点。此时需要提升算法效率。

:a:修改h值的计算方法，以使得不同最优路径上相同h值的节点估计的h值不同。这种新的值需要非常小，而且具有一定的倾向性。例如：
$$
h(n)=h(n)+cross*0.001
$$
其中cross表示起点到当前节点和当前节点到目标节点的选择倾向性的信息。

:b:Tip Breaker的有效选择会使得系统能够找到更加平滑的路线，这种路线会使得后端生成机器人移动路径更加容易。​

---

##### 方法六：Jump Point Search

​	由于图中存在许多对称性的路径，使得A*算法搜索过多的节点，而且不能保障最后选择的路径最平滑或者最适合后端路径生成，此时采用一些Tip Breaker的方法来缓解这一问题。而JPS算法可以彻底打破对称性的影响。

<font color=red>规则一：Look Ahead Rule</font>

路径裁剪规则：一般性存在直线和斜线两条路径，由于会优先选择直线路径，其次选择斜线路径，存在一下情况：

![image-20250330111512342](https://gitee.com/airporal/image_hub/raw/master/img/202503301115488.png)

> [!IMPORTANT]
>
> 如果父节点到达x节点再到达x周围节点的消耗大于或等于父节点直接到达该节点的消耗，则不从x走而从父亲直接过去。该节点称为x的虐性节点，图中灰色表示。
>
> **如上图所示，如果父亲节点直线运动到当前节点，则当前节点仅可沿直线继续运动，如果父亲节点斜线运动到当前节点，则当前节点可以向上、右以及斜线继续运动**

直线时，节点x的父节点经过x再到达2的消耗为2，父节点4到达2的消耗为$\sqrt{2}$，因此2节点为虐性节点。节点x的父节点经过x再到达3的消耗为$\sqrt{2}+1$,父节点4到达3的消耗也为$\sqrt{2}+1$，因此3也为虐性节点。

斜线时，如果原节点(6)到目标节点(2)的消耗**小于**原节点(6)经过当前节点(x)再到目标节点(2)，则裁剪当前节点到达目标节点的路径；

![image-20250523143103196](https://gitee.com/airporal/image_hub/raw/master/img/202505231431401.png)

强制经过节点(force neighbor)：当存在障碍物时，某些节点如节点3，永远无法被选择，此时设置为强制经过节点。终点也是force neighbor。

[<font color=red>规则二：Jumping Rule</font>](https://zerowidth.com/2013/a-visual-explanation-of-jump-point-search/)

**直线跳跃：**从当前节点沿着水平或者竖直的方向移动到具有force neighbor节点的y节点，如果存在y节点，则跳跃成功，将y节点放入优先队列。如果存在障碍物或者边界则跳跃失败。

**对角线跳跃：**当当前节点无法直线跳跃时，或考虑完所有直线跳跃后，沿着对角线跳跃一步，然后继续搜索直线跳跃，如果没有就继续对角线跳跃，直到找到一个节点y，y的下一个节点存在force neighbor，则将y放入Open list中。同时将x的force neighbor也放入Open list中，将x放入close list中。

![image-20250330113216220](https://gitee.com/airporal/image_hub/raw/master/img/202503301132381.png)

OpenList：所有节点或其子节点存在force neighbor的节点放入Open List。

CloseList：考虑完所有对角线跳跃的节点放入CloseList

> [!IMPORTANT]
>
> JPS并非在所有情况下都优于A*，当障碍物较为多的时候JPS效果优秀，在障碍物少的时候不一定。

##### 方法七：D*算法

> D * 算法是A*算法的改进。

​	D*算法从目标点开始搜索到当前位置的路径，每一个时间步搜索一次。搜索方法仍然是维护一个G和一个h函数，按照A* star的方法来搜索。但是除此之外，还需要维护一个rhs，用来记录局部环境是否发生改变。

​	当机器人在未知地图中运动时，无法感受全局路径，因此首先会有一个理想地图，然而随着运动过程中对机器人周围环境的感知，障碍物信息随之更新，此时并不更新全部的地图，而是通过判断rhs是否与g相同来判断局部障碍物环境是否改变，改变则更新局部路径即可。

### 2.2 基于采样

> 基于采样的运动规划，将从起点到终点的运动规划转化为拆分为若干个相同约束的子节点运动规划问题。

#### 2.2.1 概念

+ 概率完备(Probability Completeness)：当存在解的时候，一定能够找到解
+ 渐进最优(Asymptotical Optimality)：当采样次数不断增加的时候，找到最优解的概率也不断增加
+ 即时性(Anytime)：可以很快的找到最优解，且随着计算资源的增加，找到最优解的概率不断提高。

---

#### 2.2.2 Probabilistic Road Map (PRM)

​	在地图中采样出N个点，删除与障碍物发生碰撞的点，连接每个节点的相邻的点，判断边是否发生碰撞，删除发生碰撞的边，最后得到一个栅格图。然后搜索栅格图来寻找最终路径。

​	影响PRM的关键因素是碰撞检测，因此有一些针对碰撞检测过程的改进：

+ 延迟碰撞检测 Lazy collision-checking

​	在发布了若干个点后不进行碰撞检测，而是先选择一条路径，然后再对这条路径进行碰撞检测，删除掉存在碰撞的节点。

#### 2.2.3 Rapidly-exploring Random Trees(RRT)

:one: 初始化起点和目标点，维护一个图结构，存放已经拓展的节点和边，初始化图结构为仅包含起点；

:two: 在探索空间中随机生成一个点，然后连接该点到图结构中最近的点，并且沿着这一方向，随机选择一个较小的长度(以避免太长而碰撞)，将新选择的点和对应的边放入图结构；

:three:循环迭代，直到找到目标点。​

![image-20250331105331954](C:\Users\Administrator.DESKTOP-K7JDKF5\AppData\Roaming\Typora\typora-user-images\image-20250331105331954.png)

#### 2.2.4 RRT*

​	RRT star在RRT的基础上添加了拓展新节点的条件，以及跟踪节点的选择条件：

:one: 初始化起点和目标点，维护一个图结构，存放已经拓展的节点和边，初始化图结构为仅包含起点；

:two: 在探索空间中随机生成一个点，然后沿着该点到图结构中最近的点的方向，随机选择一个较小的长度(以避免太长而碰撞)生成一个新的点

:three:在新的点的规定范围内确定已经搜索到的所有的点，根据规定的法则选择其中的一个点作为新的点的父节点

:four:计算新的点到范围内除父节点外的其它店的消耗，当消耗小于某点原路径时，更新该点的F值。

:five:循环以上步骤，直到路径收敛。

​	RRT*在以上基本步骤的基础上，还可以借助一些其它的启发式方法，提高搜索速度和精度，例如：

+ 修剪节点：当某节点已经确定消耗大时，修剪该节点。
+ 延时碰撞检测：先搜索节点，然后得到路径后再进行碰撞检测。
+ 多方向搜索：从起点和终点分别进行搜索。

​	...

---

​	**RRT#**是对RRT*的改进。

​	RRT#的基本思想是在当前点和目标点之间设置一定的区域，在区域内进行采样，并不断压缩搜索区域的面积，使得搜索区间更加高效。

​	基于RRT及其改进算法是目前最常用的基于采样的路径规划的研究

![image-20250523161140726](https://gitee.com/airporal/image_hub/raw/master/img/202505231611967.png)

### 2.3 动力学约束下的运动规划

> 当不考虑动力学进行运动规划时，容易出现路径最短而不容易动力学实现，导致找到轨迹后的轨迹优化过程变为复杂，且最终得到的轨迹并不省力。

​	动力学约束下的运动规划首先需要建立系统的状态方程。$s_{i+1}=f(u_i,s_{i})$

+ 控制空间采样

​	 根据系统的状态方程，在当前状态下对控制空间进行若干次采样，并结合采样时间间隔进行积分，得到一系列的下一个状态。

+ 状态空间采样

​	根据需要的状态，有目的的在状态空间中进行采样，并反算得到控制量。

![image-20250523170133540](https://gitee.com/airporal/image_hub/raw/master/img/202505231701731.png)

​	控制空间采样比较容易，但是没有目的性，容易采样到一些无法达到的状态，状态空间采样比较有目的性和高效，但是需要进行控制量的反解，不容易实现。

​	动力学约束的路径规划和普通路径规划最大的区别是连接关键点的方式不再是直线，而是考虑动力学模型的BVP或者OBVP。即用一种最优化的方法求解满足动力学约束的关键点连线。

#### 2.3.1 约束下最优路径求解

​	有模型的情况下，建立优化的cost function,通过最优化的方法来找到最优路径。可以使用OBVP来解决。

​	标准形式：
$$
min \quad J = h(s(T))+\int_0^T g(s(t),u(t))\,dt.\\
s.t. \ \ \ \ \ \ \ \ \ \ \dot s= f(s,u)
$$
​	解决方法：

​	构建H函数：
$$
H(s,u,\lambda)=g(s,u)+\lambda^Tf(s,u),\ \ \ \lambda=(\lambda_1,\lambda_2,\lambda_3)
$$
​	求解$\dot\lambda$：
$$
\dot\lambda=-\nabla_sH(s^*,u^*,\lambda)
$$
​	得到$\lambda$的微分方程后，求出微分方程的解，然后求解：
$$
u^*(t)=argminH(s^*(t),j(t),\lambda(t)))
$$
​	最后带入状态函数中，求出状态函数关于微分方程的解的系数的函数，通过末尾、边界或其它边界条件求解这些参数。

​	然后得到损失函数的线性表达的多项式，最优问题变成多项式求根的问题，很容易求出。

​	例如：
$$
J_{\sum} = \sum_{k=1}^3 J_k, \quad J_k = \frac{1}{T}\int_0^T j_k(t)^2\,dt.\\
\dot s=f_s(s,u)=(v,z,j)
$$

---

​	基于上述方法，可以完成复杂的空间轨迹生成。此外，还可以使用轨迹库、离线策略来优化。

​	例如轨迹库，可以避免机器人陷入死胡同中。在生成轨迹时，生成多条轨迹，并通过一个打分函数进行评价，最终得到评分最高的轨迹。	

​	将动力学约束融入到基于图搜索的策略中的方法：

​	在A*算法中，需要用到h函数来估计节点到目标节点的代价，当融入动力学后，可以使用上面解决的j函数作为h函数，评估每个时刻的h。

​	还可以通过不考虑动力学约束或不考虑障碍，来优化搜索。

#### 2.3.2 Hybrid A*

​	Hybrid A*是对A*的拓展，融合了动力学影响，基于搜索的考虑动力学的运动规划。

![image-20250526104349836](https://gitee.com/airporal/image_hub/raw/master/img/202505261043159.png)

+ 对于启发函数

​	启发函数仍然需要满足A*中的要求，小于实际的h。可以使用欧氏距离、不考虑障碍物下的 2.3.1中的损失函数、不考虑动力学特性的2.3.1中的损失函数与不考虑障碍物的损失函数的融合。

+ 对于节点选取

​	将空间划分为多个栅格，每个栅格内只选择一个节点，而节点与节点之间由一系列子节点组成。新的节点为在规定时间间隔内，当前节点可到达的满足动力学约束的下一个节点。

+ 对于节点更新

​	每个时间步计算新节点的h值，并结合G值计算f值，选择f值最小的节点前进。并根据前进后的节点，更新已有节点的G值（如果更小的话）。

+ 对于节点遗忘

​	当某个节点再次被更新后，将它到达旧的父亲节点的轨迹上的所有节点都遗忘，仅仅保留新父亲节点到该节点的轨迹。因为连线上的子节点不再满足新路径的动力学约束。

此外，还有基于采样与动力学模型的路径规划，例如kRRT。

### 2.4 基于优化的轨迹规划

​	基于优化的轨迹优化是局部轨迹规划的一种方法，可以处理复杂的动力学约束问题，但通常只能找到局部最优解。

​	动力学特性：

+ **Differential flatness**

​	对于一个动力学方程，对应着高纬空间的曲面，收到一些动力学微分方程的约束。若动力学满足微分平坦特性，即存在一个平坦输出z，可以用z及z的高阶导数来表示系统输入x、输出a，则系统微分平坦。而z不受任意约束。

​	此时将高纬曲面拉平到z所在空间平面，此时z不受微分约束，且z的任意取值都对应曲面上的一个输入输出。

​	因此，微分平坦特性使得受微分约束的优化问题转变为平坦空间的无约束优化问题。

​	但是平坦空间到曲面的映射中存在一些动力学的奇异点。

> 很多模型都有微分平坦特性，对动力学方程进行适当推导得到微分平坦的表达，再进行优化可以使得效率提升10倍以上。

​	生成指定的优化路径后，路径并不一定顺滑，因此可以在小段路径上指定一个边界条件（如节点速度），这样解这个边界条件（BVP）可以得到比较平滑的轨迹。

+ 连续时间约束

​	对需要优化的轨迹，需要指定每段轨迹的时间，但是时间的分配会极大的影响最终轨迹。

+ BVIP（Boundary-intermediate value problem）
+ constrained 约束

![image-20250524164610269](C:\Users\Administrator.DESKTOP-K7JDKF5\AppData\Roaming\Typora\typora-user-images\image-20250524164610269.png)

### 2.5 模型预测控制与运动规划

> MPC及已知系统的模型，在每个时刻，使用系统的动力学模型，优化得到未来小段时间内的控制量，并选择第一个输入进行控制。重复迭代此过程。

![image-20250525222318803](C:\Users\Administrator.DESKTOP-K7JDKF5\AppData\Roaming\Typora\typora-user-images\image-20250525222318803.png)

MPC考虑未来一小段时间的决策，相比于最优控制减少了优化规模。还可以拿上次求解的结果作为这次求解的初值（warm-start）。

MPC需要求解矩阵的逆，比较复杂。

MPC还可以考虑系统延时的情况。

LQR：线性二次型调节器，是一种使用动态规划的方法解决MPC问题的方法，通过假设第k-1时刻状态已知，求第k时刻状态，并带入到损失函数中求第k-1时刻的最优输入，依此迭代到第0时刻的最优输入。

MPC包含约束时，变成一个QP问题，使用优化库解决。

显示MPC可以直接预先算好对应的解，在执行时查表即可。当问题可能性太大时，导致内存问题。

对于非线性系统，连续非线性模型可以通过泰勒展开得到线性时变模型。然后使用差分代替微分来建立模型。

也可以直接求解非线性MPC问题，即NLP问题。非线性MPC无法保证模型的可解性。

Tube MPC：用一个简单的简化的模型来代替原来的非线性模型，称为Tube，Tube做优化输出并不直接作用在系统控制上，而是在Tube后接上一个控制器，来跟踪系统误差。TubeMPC用一个简化的模型来将系统约束到一个比较好的范围内进行控制。

![image-20250525220657167](C:\Users\Administrator.DESKTOP-K7JDKF5\AppData\Roaming\Typora\typora-user-images\image-20250525220657167.png)

Hybrid MPC对于不连续系统，系统的状态在有限的状态机之间切换。此时系统的约束变为逻辑约束。MLD混合逻辑系统指系统中既有连续约束，又有逻辑约束。解决MLD问题，通常引入逻辑变量来将MLD问题转换为连续问题。

MPCC：用于跟踪轨迹和控制精度之间的权衡。首先将非线性系统转换为线性时变系统，然后采用TubeMpc来提高系统的抗扰动性。

### 2.6 Fast Planner

前端

+ 使用基于搜索或者基于采样的算法求出一条轨迹来
  + 动力学约束
  + 状态方程
  + 两点之间路径使用多项式拟合

后端

+ 在搜索到的轨迹的基础上进行优化

  + bezier 曲线：通过基函数来拟合前端找到的多个节点。问题是随着节点的增加，曲线阶数也在增加，bezier曲线的任何一个控制点的变化都会对曲线产生明显影响。

    **B-spline**是一种特殊的bezier曲线，分段对各个节点之间的曲线使用bezier曲线进行拟合。B样条曲线的某个控制点移动时，有固定的影响范围，并不对整段轨迹都产生影响。n阶b样条的导数是n-1阶B样条。

    均匀B样条

  + 轨迹优化问题

    对控制点进行优化，最终目的是找到使得cost function最小的控制点。

    当使用均匀b样条进行优化时，可能出现碰撞要求与动力学条件违背，此时通常先满足碰撞要求，然后再通过调整时间间隔来使得轨迹满足动力学条件。



























